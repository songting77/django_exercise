# 自定义用户模型

​	1 在models.py 新建一个继承自AbstractUser的用户模型类

​	2 拓展自己需要的字段

​	3 做迁移

备注：如果迁移失败 可以去尝试删除系统的用户表 重新做迁移

# 自定义登录

1 写一个自己的登录认证类（要继承ModelBack）

~~~
from django.contrib.auth.backends import ModelBackend
# 你自己的用户类
from .models import MyUser


class MyBackend(ModelBackend):
    def authenticate(self, request, username=None, password=None, **kwargs):
    	#思路
        	# 找用户
       		# 做验证密码

        # 找人
        user = None
        try:
            user = MyUser.objects.get(username=username)
        except:
            try:
                user = MyUser.objects.get(phone=username)
            except:
                return None
        #
        if user.check_password(password):
            return user
        else:
            return None
~~~

2 修改settings文件

~~~
# 指定认证的类
AUTHENTICATION_BACKENDS = (
    '你APP的名字.文件名.MyBackend（认证类名）',
)
~~~

3 使用

~~~
from django.contrib.auth import authenticate, login
from django.http import HttpResponse
from django.shortcuts import render, redirect


# Create your views here.

def my_login(req):
    if req.method == 'GET':
        return render(req, 'login.html')
    else:
        params = req.POST
        u_name = params.get('u_name')
        pwd = params.get("pwd")
        # 数据校验

        # 用户校验
        user = authenticate(username=u_name, password=pwd)
        if user:
            # 将用户登录
            login(req, user)
            # 跳转
            return redirect('/t6/index')
        else:
            return HttpResponse('用户名或者密码错误')
~~~

# 拓展：@login_required()

​	用途：保证某个API 在用户调用调用的时候 保证用户是登录状态

​		login_url参数 指定的值是我们自己的登录页面的url

​	示例：

~~~
@login_required(login_url="/t6/login")
def index(req):
    # 拿用户
    user = req.user
    return render(req, 'index.html', {'u_name': user.username})
~~~

# 中间件

​	在Django处理的请求的各个处理阶段 我们可以插入自己的逻辑

## 	怎么写中间件

​		\1. 在工程目录下创建middleware目录

​		\2. 目录中创建一个python文件

​		\3. 在python文件中导入中间件的基类

​		\4. 在类中根据功能需求，创建切入需求类，重写切入点方法

​		\5、启用中间件，在settings中进行配置，MIDDLEWARE中添加

  			middleware.文件名.类名

使用示例 中间件代码如下

~~~
from django.shortcuts import render
from django.utils.deprecation import MiddlewareMixin

class MyMiddleWare(MiddlewareMixin):

    def process_request(self, req):
        ip = req.META.get("REMOTE_ADDR")
        white_ips = [
            # '10.3.133.22',
            '10.3.133.9',
            '10.3.133.141',
            '10.3.133.11'
        ]
        if ip in white_ips:
            return render(req, 'home.html', {'data':[]})

~~~

# 上传图片

## 	1要写一个对应model

​			imageField

## 	2 前端

​			form表单上传文件需要添加enctype='multipart/form-data'

​			文件上传必须使用POST请求方式

​			至少要包含一个类型是file的input标签

## 	3 后端

​			在static文件夹下创建uploadefiles用与存储接收上传的文件

  			在settings中配置，MEDIA_ROOT=os.path.join(BASE_DIR,r'static/uploadefiles')

​			拿文件 给对象赋值

~~~
		原生的写法
		# 拿文件
        icon = req.FILES['u_icon']
        # 保存头像
        user.icon = icon
        user.save()
        # 拼接返回数据
        data = {
            'u_name': user.username,
            'icon': "/static/uploadefiles/" + user.icon.url
        }
      
        return render(req, 'person.html', data)
~~~

原生实现

~~~
  		# 原生
        # 拿文件数据
        icon = req.FILES['u_icon']
        # print(icon.name)
        
        # 生成随机文件名字
        file_name = "icons/" + get_random_str() + ".jpg"
        print(file_name)
        
        # 拼接一个自己的文件路径
        image_path = os.path.join(settings.MEDIA_ROOT, file_name)
        
        # 打开你拼接的那个文件路径
        with open(image_path, 'wb') as fp:
            # 遍历图片文件的块数据
            for i in icon.chunks():
                # 将图片数据 写入到我们自己的那个文件
                fp.write(i)
~~~



# 获得随机字符串

```
import uuid
import hashlib

def get_random_str():
    # 获得uuid值
    uuid_val = uuid.uuid4()
    # 将uuid值转成字符串
    uuid_str = str(uuid_val).encode("utf-8")
    # 获得md5实例
    md5 = hashlib.md5()
    # 将uuid字符串做摘要
    md5.update(uuid_str)
    # 返回固定长度的字符串
    return md5.hexdigest()
```
# 后端分页

​	1 拿到数据集

​	2 创建分页对象

​	3 根据用户指定页码 拿到对应page实例

​	4 将对应page实例对应的数据返回给前端

~~~
from django.core.paginator import Paginator
from django.http import HttpResponse
from django.shortcuts import render
from t6.models import MyUser
# Create your views here.

#指定每一页有几个数据
USER_PEER_PAGE_NUM = 5

def get_user_by_num(req, page_num):
    page_num = int(page_num)
    # 获得全部用户
    users = MyUser.objects.all()
    
    # 创建分页
    paginator = Paginator(
        users,
        USER_PEER_PAGE_NUM
    )
    
    # 参数校验
    if page_num <= 0 or page_num > paginator.num_pages:
        return HttpResponse("没数据了")
        
    # 拿到用户指定页面的那页数据
    page = paginator.page(page_num)
    
    # 返回给用户数据
    data = {
        'users': page.object_list
    }
    return render(req, 'users.html', data)

~~~

urls.py配置

~~~
url(r"^user/(\d+)", get_user_by_num)
~~~

# 需求：

​	做一个注册功能

​	跳转到登录页面

​	能支持 用户名 手机号 邮箱登录

​	跳转到首页 允许我上传头像



创建一百个陈独秀

练习分页